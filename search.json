[{"path":"https://hassanpazira.github.io/BFI/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 BFI authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://hassanpazira.github.io/BFI/articles/BFI.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"An Introduction to BFI","text":"R package BFI (Bayesian Federated Inference) provides several functions carry Bayesian Federated Inference method two kinds models (GLM Survival) multicenteral data without combining/sharing . tutorial focus GLM , version package available two commonly used families: \"binomial\" \"gaussian\". mostly using functions include bfi(), MAP.estimation(), inv.prior.cov(). following, see BFI package can applied real data sets included package. trauma data can utilized \"binomial\" family Nurses data can used \"gaussian\". avoid repetition, use trauma data set.","code":""},{"path":"https://hassanpazira.github.io/BFI/articles/BFI.html","id":"how-to-use-it","dir":"Articles","previous_headings":"","what":"How to use it?","title":"An Introduction to BFI","text":"go , attach package, load/attach trauma data: data set consists data 371 trauma patients three hospitals (peripheral hospital without neuro-surgical unit, status=1, peripheral hospital neuro-surgical unit, status=2, academic medical center, status=3). information data set use 6 columns: covariates sex (dichotomous), age (continuous), ISS (Injury Severity Score, continuous), GCS (Glasgow Coma Scale, continuous) predictors, mortality response variable. hospital categorical variable indicates hospitals involved study.","code":"# install BFI from GitHub devtools::install_github(\"hassanpazira/BFI\") ##  ## ── R CMD build ───────────────────────────────────────────────────────────────── ## * checking for file ‘/tmp/Rtmp4DJERH/remotes19c43b7dd4da/hassanpazira-BFI-b094c12/DESCRIPTION’ ... OK ## * preparing ‘BFI’: ## * checking DESCRIPTION meta-information ... OK ## * excluding invalid files ## Subdirectory 'R' contains invalid file names: ##   ‘BFI_from_Python.py’ ‘SBFI.py’ ## * checking for LF line-endings in source and make files and shell scripts ## * checking for empty or unneeded directories ## * building ‘BFI_0.6.4.tar.gz’ # load BFI library(BFI)  # load `trauma` data data(\"trauma\") # attach the data attach(trauma) ?trauma colnames(trauma) ## [1] \"sex\"       \"age\"       \"hospital\"  \"ISS\"       \"GCS\"       \"mortality\""},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"BFI in Python","text":"R package BFI (Bayesian Federated Inference)","code":""},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"python-instalation","dir":"Articles","previous_headings":"","what":"Python Instalation","title":"BFI in Python","text":"steps install latest version Python ‘MacOS’ ‘Ubuntu’:","code":""},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"for-macos","dir":"Articles","previous_headings":"Python Instalation","what":"For MacOS","title":"BFI in Python","text":"","code":"# install BFI from GitHub devtools::install_github(\"hassanpazira/BFI\") # load BFI library(BFI)  # load `trauma` data data(\"trauma\") # attach the data attach(trauma)"},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"for-ubuntu","dir":"Articles","previous_headings":"Python Instalation","what":"For Ubuntu","title":"BFI in Python","text":"","code":"?trauma"},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"installing-pip","dir":"Articles","previous_headings":"","what":"Installing PIP","title":"BFI in Python","text":"PIP (Python package manager) helps us install use various packages/modules Python programming. Install/Upgrade latest version PIP running following command:","code":""},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"on-macos","dir":"Articles","previous_headings":"Installing PIP","what":"On MacOS","title":"BFI in Python","text":"","code":"colnames(trauma) ## [1] \"sex\"       \"age\"       \"hospital\"  \"ISS\"       \"GCS\"       \"mortality\""},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"on-ubuntu","dir":"Articles","previous_headings":"Installing PIP","what":"On Ubuntu","title":"BFI in Python","text":"","code":"colnames(trauma) ## [1] \"sex\"       \"age\"       \"hospital\"  \"ISS\"       \"GCS\"       \"mortality\""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/articles/Python.html","id":"python-script","dir":"Articles","previous_headings":"","what":"Python script","title":"BFI in Python","text":"Now move work ‘rpy2’ inside Python script! First type following command terminal window go Python Environment:","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hassan Pazira. Author, maintainer. Marianne . Jonker. Author. Anthony C.C. Coolen. Author.","code":""},{"path":"https://hassanpazira.github.io/BFI/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pazira H, Jonker M, Coolen (2023). BFI: Bayesian Federated Inference. R package version 0.6.4, https://hassanpazira.github.io/BFI/.","code":"@Manual{,   title = {BFI: Bayesian Federated Inference},   author = {Hassan Pazira and Marianne A. Jonker and Anthony C.C. Coolen},   year = {2023},   note = {R package version 0.6.4},   url = {https://hassanpazira.github.io/BFI/}, }"},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"bfi-","dir":"","previous_headings":"","what":"Bayesian Federated Inference","title":"Bayesian Federated Inference","text":"Bayesian Federated Inference","code":""},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Bayesian Federated Inference","text":"Due limited size available data sets especially rare diseases, sometimes challenging identify relevant predictive features using multivariable statistical analysis. issue may resolved combining data multiple centers one centralized location without sharing data , difficult reality privacy security concerns. address challenges, developed implemented Bayesian Federated Inference (BFI) framework multicenter data. aims leverage statistical power larger (combined) data sets without requiring data aggregated one location. BFI framework allows center using local data infer optimal parameter values well additional features posterior parameter distribution able gather information captured alternative techniques. One benefit BFI alternative approaches , one inference cycle across centers required BFI. R package called BFI created perform Bayesian Federated Inference. following instructions install development version BFI package computer.","code":""},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"install-r-and-rstudio","dir":"","previous_headings":"","what":"Install R and RStudio","title":"Bayesian Federated Inference","text":"First, need install R RStudio: Install R Install RStudio Desktop (R installed) details installing R RStudio, see page. need help learning R, see RStudio Education.","code":""},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"install-bfi-package","dir":"","previous_headings":"","what":"Install BFI package","title":"Bayesian Federated Inference","text":"order install BFI package directly Github, need devtools package. Invoke R RStudio type (Console) load typing: Next, install BFI follows: package can now loaded R used :","code":"if(!require(devtools)) {install.packages(\"devtools\")} library(devtools) devtools::install_github(\"hassanpazira/BFI\", force = TRUE) library(BFI)"},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"update","dir":"","previous_headings":"","what":"Update","title":"Bayesian Federated Inference","text":"latest version BFIpackage 0.6.4. check current version BFI installed R library, use:","code":"packageVersion(\"BFI\")"},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"details","dir":"","previous_headings":"","what":"Details","title":"Bayesian Federated Inference","text":"BFI package provides several functions, important following two main functions: MAP.estimation(): used centers, result sent central server. bfi(): used central server. access R documentation functions, example bfi(), enter following command:","code":"help(bfi, package = \"BFI\")    # or, equivalently, after loading the BFI package  ?bfi"},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Bayesian Federated Inference","text":"Let’s look following example see BFI package can used. examples details look BFI vignette typing use vignette(\"BFI\") see BFI vignette Help tab RStudio. Now, generate two independent (local) data sets Gaussian distribution, apply package see works. First apply function MAP.estimation() local data, apply bfi() function aggregated results.","code":"devtools::install_github(\"hassanpazira/BFI\", dependencies = TRUE, build_vignettes = TRUE, force = TRUE) browseVignettes(\"BFI\")  # to see all vignettes from the BFI package in an HTML browser. # Load the BFI package library(BFI)  # model assumption: beta <- 1:4  # regression coefficients (beta[1] = 1 is the intercept)  #----------------------------------------------------- # Data Simulation for local center 1 when y ~ Binomial #----------------------------------------------------- n1 <- 30                                           # sample size of center 1 X1 <- data.frame(x1=rnorm(n1),                     # continuous variable                  x2=sample(0:2, n1, replace=TRUE)) # categorical variable # make dummy variables X1x2_1 <- ifelse(X1$x2 == '1', 1, 0) X1x2_2 <- ifelse(X1$x2 == '2', 1, 0) X1$x2  <- as.factor(X1$x2) # linear predictor: eta1   <- beta[1] + X1$x1 * beta[2] + X1x2_1 * beta[3] + X1x2_2 * beta[4] # inverse of the link function ( g^{-1}(\\eta) = \\mu ): mu1    <- binomial()$linkinv(eta1) y1     <- rbinom(n1, 1, mu1)  #----------------------------------------------------- # Data Simulation for local center 2 when y ~ Binomial #----------------------------------------------------- n2 <- 50                                           # sample size of center 2 X2 <- data.frame(x1=rnorm(n2),                     # continuous variable                  x2=sample(0:2, n2, replace=TRUE)) # categorical variable # make dummy variables: X2x2_1 <- ifelse(X2$x2 == '1', 1, 0) X2x2_2 <- ifelse(X2$x2 == '2', 1, 0) X2$x2  <- as.factor(X2$x2) # linear predictor: eta2   <- beta[1] + X2$x1 * beta[2] + X2x2_1 * beta[3] + X2x2_2 * beta[4] # inverse of the link function: mu2    <- binomial()$linkinv(eta2) y2     <- rbinom(n2, 1, mu2)  # assume the same inverse covariance matrix (Lambda) for both centers: Lambda <- inv.prior.cov(X1, lambda=0.01, family=binomial)  #-------------------------- # MAP estimates at center 1 #-------------------------- fit1       <- MAP.estimation(y1, X1, family=binomial, Lambda) theta_hat1 <- fit1$theta_hat # intercept and coefficient estimates for center 1 A_hat1     <- fit1$A_hat     # curvature matrix for center 1  #-------------------------- # MAP estimates at center 2 #-------------------------- fit2       <- MAP.estimation(y2, X2, family=binomial, Lambda) theta_hat2 <- fit2$theta_hat # intercept and coefficient estimates for center 2 A_hat2     <- fit2$A_hat     # curvature matrix for center 2  #---------------------- # BFI at central center #---------------------- A_hats     <- list(A_hat1, A_hat2) theta_hats <- list(theta_hat1, theta_hat2) bfi_fit    <- bfi(theta_hats, A_hats, Lambda) class(bfi_fit) summary(bfi_fit, cur_mat = TRUE)  #-------------------- # stratified analysis #-------------------- bfi(theta_hats, A_hats, Lambda, stratified = TRUE, strat_par = 1L)"},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Bayesian Federated Inference","text":"cite BFI publications, please use:","code":"citation(\"BFI\")"},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Federated Inference","text":"technical papers package: Generalized Linear Models (GLMs) Survival Models","code":""},{"path":"https://hassanpazira.github.io/BFI/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Bayesian Federated Inference","text":"find errors, suggestions, like request something added, please file issue issue report send email : hassan.pazira@radboudumc.nl.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-internal.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal BFI Functions — BFI-internal","title":"Internal BFI Functions — BFI-internal","text":"Internal BFI functions.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-internal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Internal BFI Functions — BFI-internal","text":"Hassan Pazira","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-internal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal BFI Functions — BFI-internal","text":"functions intended use users.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian Federated Inference — BFI-package","title":"Bayesian Federated Inference — BFI-package","text":"Bayesian Federated Inference method combines inference results different (medical) centers without sharing data. version package, user can fit models specifying Gaussian Binomial (Logistic) families. package updated models soon.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian Federated Inference — BFI-package","text":"MAP.estimation bfi main functions. functions utility functions. examples provided vignettes accompanying package order show package can applied real data. vignettes can found package website https://hassanpazira.github.io/BFI/ within R package installed, e.g. via vignette(\"BFI\", package = \"BFI\").","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian Federated Inference — BFI-package","text":"Hassan Pazira, Marianne . Jonker, Anthony C.C. Coolen Maintainer: Hassan Pazira hassan.pazira@radboudumc.nl","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian Federated Inference — BFI-package","text":"Jonker M.., Pazira H. Coolen .C.C. (2023). Bayesian Federated Inference Statistical Models, Statistics Medicine, Vol. 0(0), 0-0. <https://doi.org/10.48550/arXiv.2302.07677>","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian Federated Inference — bfi","title":"Bayesian Federated Inference — bfi","text":"bfi function can used (central server) combine inference results separate data sets (without combining data) approximate inferred data sets merged. now function can handle linear logistic regression models, code models available near future. bfi command","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian Federated Inference — bfi","text":"","code":"bfi(theta_hats = NULL, A_hats, Lambda, stratified = FALSE,     strat_par = NULL, center_spec = NULL, type = \"cat\")"},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian Federated Inference — bfi","text":"theta_hats list \\(L\\) vectors maximum posteriori (MAP) estimates model parameters \\(L\\) centers. vectors must equal dimensions. See ‘Details’. A_hats list \\(L\\) curvature matrices \\(L\\) centers. matrices must equal dimensions. See ‘Details’. Lambda list \\(L+1\\) matrices. matrix used prior inverse variance-covariance matrix Gaussian distribution. first \\(L\\) matrices \\(L\\) local centers last one chosen variance-covariance matrix Gaussian prior (fictive) combined data set. stratified = FALSE, \\(L+1\\) matrices must equal dimensions. , stratified = TRUE, first \\(L\\) matrices must equal dimensions last matrix different (greater) dimention others. stratified = FALSE \\(L+1\\) matrices equal, sufficient give (list one) matrix . stratified = TRUE first \\(L\\) matrices equal, argument can list two matrices, fist matrix represents chosen variance-covariance matrix local centers second one chosen matrix combined data set. See ‘Details’. stratified logical flag performing stratified analysis. stratified = TRUE, parameter(s) selected strat_par argument allowed different across centers. Default stratified = FALSE. See ‘Details’ ‘Examples’. strat_par one- two-element integer vector indicating stratification parameter(s). values \\(1\\) /\\(2\\) /used indicate ``intercept'' /``sigma2'' allowed vary, respectively. argument used stratified = TRUE. Default strat_par = NULL, stratified = TRUE, strat_par can NULL. binomial family length vector one refers ``intercept'', value element \\(1\\). gaussian vector can \\(1\\) indicating ``intercept'' , \\(2\\) indicating ``sigma2'' , c(\\(1\\), \\(2\\)) ``intercept'' ``sigma2''. See ‘Examples’. center_spec vector \\(L\\) elements representing center specific variable. argument used stratified = TRUE. element represents specific feature corresponding center. must one specific value attribute center. vector numeric, characteristic factor vector. Note , order centers vector center_spec must folllowed vectors argument theta_hats. center_spec = NULL (default), stratification parameter(s) given argument strat_par assumed different across centers. See ‘Details’ ‘Examples’. type description method used measure complexity fitted models. argument used center_spec NULL. .","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian Federated Inference — bfi","text":"bfi returns list containing following components: theta_hat vector estimates obtained combining inference results \\(L\\) centers 'BFI' methodology. intercept fitted every centers stratified = FALSE, one general ``intercept'' vector, stratified = TRUE, \\(L\\) different local intercepts model; A_hat minus curvature (Hessian) matrix obtained 'BFI' method combined model. stratified = TRUE, dimension matrix always greater stratified = FALSE. stratified = TRUE, able show result one (combined) matrix, exist NA's matrix, matrix invertible anymore; sd vector standard deviation estimates theta_hat obtained matrix A_hat, .e., vector equals sqrt(diag(solve(A_hat))).","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian Federated Inference — bfi","text":"bfi function implements BFI approach described paper Jonker et. al. (2023) given references. inference results gathered different (\\(L\\)) centers combined, BFI estimates model parameters curvature matrix evaluated point returned. inference result center must obtained using MAP.estimation function separately, results (coming different centers) compiled list used input bfi(). models different centers defined exactly way; among others, exactly covariates included models. parameter vectors defined exactly , estimates theta_hat's A_hat's (output MAP.estimation function) defined way (e.g., covariates need included models order). Note order estimates respect centers lists theta_hats, A_hats Lambda must , every list element \\(\\ell^{\\th}\\) position center \\(\\ell\\). also case vector center_spec. last matrix list argument Lambda built function inv.prior.cov() stratified = TRUE. intercept = FALSE locations, binomial family stratified analysis possible anymore. Details related center_spec may added!!!....","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian Federated Inference — bfi","text":"Jonker M.., Pazira H. Coolen .C.C. (2023). Bayesian Federated Inference Statistical Models. Statistics Medicine, Vol. 0(0), 0-0. <https://doi.org/10.48550/arXiv.2302.07677>","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian Federated Inference — bfi","text":"Hassan Pazira Maintainer: Hassan Pazira hassan.pazira@radboudumc.nl","code":""},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/reference/BFI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian Federated Inference — bfi","text":"","code":"#------------- # y ~ Binomial #------------- # model assumption: beta <- 1:4  # regression coefficients (beta[1] = 1 is the intercept)  #----------------------------------- # Data Simulation for local center 1 #----------------------------------- n1 <- 30                                           # sample size of center 1 X1 <- data.frame(x1=rnorm(n1),                     # continuous variable                  x2=sample(0:2, n1, replace=TRUE)) # categorical variable # make dummy variables X1x2_1 <- ifelse(X1$x2 == '1', 1, 0) X1x2_2 <- ifelse(X1$x2 == '2', 1, 0) X1$x2  <- as.factor(X1$x2) # linear predictor: eta1   <- beta[1] + X1$x1 * beta[2] + X1x2_1 * beta[3] + X1x2_2 * beta[4] # inverse of the link function ( g^{-1}(\\eta) = \\mu ): mu1    <- binomial()$linkinv(eta1) y1     <- rbinom(n1, 1, mu1)  #----------------------------------- # Data Simulation for local center 2 #----------------------------------- n2 <- 50                                           # sample size of center 2 X2 <- data.frame(x1=rnorm(n2),                     # continuous variable                  x2=sample(0:2, n2, replace=TRUE)) # categorical variable # make dummy variables: X2x2_1 <- ifelse(X2$x2 == '1', 1, 0) X2x2_2 <- ifelse(X2$x2 == '2', 1, 0) X2$x2  <- as.factor(X2$x2) # linear predictor: eta2   <- beta[1] + X2$x1 * beta[2] + X2x2_1 * beta[3] + X2x2_2 * beta[4] # inverse of the link function: mu2    <- binomial()$linkinv(eta2) y2     <- rbinom(n2, 1, mu2)  #-------------------------- # MAP estimates at center 1 #-------------------------- # assume the same inverse covariance matrix (Lambda) for both centers: Lambda     <- inv.prior.cov(X1, lambda=0.01, family=binomial) fit1       <- MAP.estimation(y1, X1, family=binomial, Lambda) theta_hat1 <- fit1$theta_hat # intercept and coefficient estimates A_hat1     <- fit1$A_hat     # curvature matrix  #-------------------------- # MAP estimates at center 2 #-------------------------- fit2       <- MAP.estimation(y2, X2, family=binomial, Lambda) theta_hat2 <- fit2$theta_hat A_hat2     <- fit2$A_hat  #---------------------- # BFI at central center #---------------------- A_hats     <- list(A_hat1, A_hat2) theta_hats <- list(theta_hat1, theta_hat2) bfi        <- bfi(theta_hats, A_hats, Lambda) #> [[1]] #> (Intercept)          x1         x21         x22  #>    1.318938    1.479303    4.439754    4.897699  #>  #> [[2]] #> (Intercept)          x1         x21         x22  #>   0.9451324   2.9101245   3.8640988   8.7129555  #>  #> [[1]] #>             (Intercept)          x1         x21         x22 #> (Intercept)  1.81531344 -0.78408997  0.04408491  0.04857990 #> x1          -0.78408997  1.03076198 -0.01727774 -0.04085158 #> x21          0.04408491 -0.01727774  0.05408491  0.00000000 #> x22          0.04857990 -0.04085158  0.00000000  0.05857990 #>  #> [[2]] #>             (Intercept)        x1        x21         x22 #> (Intercept)  3.57076342 -2.218759  0.8670012  0.08113926 #> x1          -2.21875882  3.402719 -1.3019486 -0.19123401 #> x21          0.86700118 -1.301949  0.8770012  0.00000000 #> x22          0.08113926 -0.191234  0.0000000  0.09113926 #>  #>             (Intercept)   x1  x21  x22 #> (Intercept)        0.01 0.00 0.00 0.00 #> x1                 0.00 0.01 0.00 0.00 #> x21                0.00 0.00 0.01 0.00 #> x22                0.00 0.00 0.00 0.01 class(bfi) #> [1] \"bfi\" summary(bfi, cur_mat = TRUE) #>  #> Summary of the model: #>  #>     Family: ‘binomial’  #>       Link: ‘Logit’ #>  #> Coefficients: #>  #>             Estimate Std.Dev CI 2.5% CI 97.5% #> (Intercept)   1.1065  0.5479  0.0327   2.1803 #> x1            2.3079  0.7800  0.7792   3.8366 #> x21           2.9623  1.4284  0.1626   5.7620 #> x22           7.1350  2.9079  1.4357  12.8343 #>  #> Dispersion parameter (sigma2):  1  #>  #> Curvature Matrix:  #>  #>             (Intercept)      x1     x21     x22 #> (Intercept)      5.3761 -3.0028  0.9111  0.1297 #> x1              -3.0028  4.4235 -1.3192 -0.2321 #> x21              0.9111 -1.3192  0.9211  0.0000 #> x22              0.1297 -0.2321  0.0000  0.1397  #-------------------- # stratified analysis #-------------------- bfi(theta_hats, A_hats, Lambda, stratified = TRUE) # Error #> [[1]] #> (Intercept)          x1         x21         x22  #>    1.318938    1.479303    4.439754    4.897699  #>  #> [[2]] #> (Intercept)          x1         x21         x22  #>   0.9451324   2.9101245   3.8640988   8.7129555  #>  #> [[1]] #>             (Intercept)          x1         x21         x22 #> (Intercept)  1.81531344 -0.78408997  0.04408491  0.04857990 #> x1          -0.78408997  1.03076198 -0.01727774 -0.04085158 #> x21          0.04408491 -0.01727774  0.05408491  0.00000000 #> x22          0.04857990 -0.04085158  0.00000000  0.05857990 #>  #> [[2]] #>             (Intercept)        x1        x21         x22 #> (Intercept)  3.57076342 -2.218759  0.8670012  0.08113926 #> x1          -2.21875882  3.402719 -1.3019486 -0.19123401 #> x21          0.86700118 -1.301949  0.8770012  0.00000000 #> x22          0.08113926 -0.191234  0.0000000  0.09113926 #>  #>             (Intercept)   x1  x21  x22 #> (Intercept)        0.01 0.00 0.00 0.00 #> x1                 0.00 0.01 0.00 0.00 #> x21                0.00 0.00 0.01 0.00 #> x22                0.00 0.00 0.00 0.01 #> Error in bfi(theta_hats, A_hats, Lambda, stratified = TRUE): In stratified analysis, 'strat_par' should not be 'NULL'. Select the stratification parameter(s). bfi(theta_hats, A_hats, Lambda, stratified = TRUE, strat_par = 1L) #> [[1]] #> (Intercept)          x1         x21         x22  #>    1.318938    1.479303    4.439754    4.897699  #>  #> [[2]] #> (Intercept)          x1         x21         x22  #>   0.9451324   2.9101245   3.8640988   8.7129555  #>  #> [[1]] #>             (Intercept)          x1         x21         x22 #> (Intercept)  1.81531344 -0.78408997  0.04408491  0.04857990 #> x1          -0.78408997  1.03076198 -0.01727774 -0.04085158 #> x21          0.04408491 -0.01727774  0.05408491  0.00000000 #> x22          0.04857990 -0.04085158  0.00000000  0.05857990 #>  #> [[2]] #>             (Intercept)        x1        x21         x22 #> (Intercept)  3.57076342 -2.218759  0.8670012  0.08113926 #> x1          -2.21875882  3.402719 -1.3019486 -0.19123401 #> x21          0.86700118 -1.301949  0.8770012  0.00000000 #> x22          0.08113926 -0.191234  0.0000000  0.09113926 #>  #>             (Intercept)   x1  x21  x22 #> (Intercept)        0.01 0.00 0.00 0.00 #> x1                 0.00 0.01 0.00 0.00 #> x21                0.00 0.00 0.01 0.00 #> x22                0.00 0.00 0.00 0.01 #> Error in bfi(theta_hats, A_hats, Lambda, stratified = TRUE, strat_par = 1L): The last matrix in 'Lambda' should not have the same dim. as the other local matrices."},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum A Posteriori estimation — MAP.estimation","title":"Maximum A Posteriori estimation — MAP.estimation","text":"MAP.estimation function used (local centers) compute Maximum Posterior (MAP) estimators parameters GLM soon Survival models.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum A Posteriori estimation — MAP.estimation","text":"","code":"MAP.estimation(y, X, family = gaussian, Lambda, intercept = TRUE,                initial = NULL, control = list())"},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum A Posteriori estimation — MAP.estimation","text":"y response vector. binomial family used, argument vector entries 0 (failure) 1 (success). Alternatively, response can matrix first column number “successes” second column number “failures”. X design matrix dimension \\(n \\times p\\), \\(p\\) number covariables predictors. family description error distribution link function used specify model. can character string naming family function result call family function (see family details). current version package, family model can gaussian (identity link function) binomial (logit link function). default gaussian family used. case linear regression model, family = gaussian, extra model parameter variance measurement error. Lambda inverse variance-covariance matrix Gaussian distribution used prior distribution model parameters. dimension matrix depends number columns X, type covariates (continuous/dichotomous categorical), family, intercept. However, Lambda can also easily created inv.prior.cov(). intercept logical flag fitting intercept. intercept=TRUE (default), intercept fitted, .e., included model, intercept=FALSE set zero, .e., model anymore. initial vector specifying initial values parameters optimized . length initial equal number model parameters thus, equal number rows columns Lambda. Since 'L-BFGS-B' method used algorithm, values always finite. Default vector zeros. control list control parameters. See ‘Details’.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum A Posteriori estimation — MAP.estimation","text":"MAP.estimation returns list containing following components: theta_hat vector corresponding maximum posteriori (MAP) estimates parameters; A_hat minus curvature (Hessian) matrix around point theta_hat. dimension matrix argument Lambda; sd vector standard deviation MAP estimates theta_hat, sqrt(diag(solve(A_hat))); Lambda inverse variance-covariance matrix Gaussian distribution used prior distribution parameters. exactly argument Lambda; formula formula supplied; names names model parameters; n sample size; np number coefficients; value value minus log-likelihood posterior density corresponding  theta_hat; family family object used.; intercept logical flag used fit intercept TRUE, set zero FALSE; convergence integer value used encode warnings errors related algorithm used fit model. values returned : 0 algorithm converged; 1 maximum number iterations ('maxit') reached; 2 Warning 'L-BFGS-B' method. See message value; control list control parameters used compute MAP estimates.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum A Posteriori estimation — MAP.estimation","text":"MAP.estimation function finds Maximum Posteriori (MAP) estimates model parameters maximizing log-posterior density respect parameters, .e., values associated peak log-posterior distribution (posterior mode). words, MAP.estimation() optimizes log-posterior density respect parameter vector obtain MAP estimation. addition model parameters, .e., coefficients (\\({\\beta}\\)'s) variance error (\\(\\sigma^2_e\\)), curvature matrix (Hessian log-posterior) estimated around mode. MAP.estimation function returns object class `bfi`. Therefore, summary() can used object returned MAP.estimation(). solve unconstrained bound-constrained optimization problems, MAP.estimation function utilizes optimization algorithm called Limited-memory Broyden-Fletcher-Goldfarb-Shanno Bound Constraints (L-BFGS-B), Byrd et. al. (1995). L-BFGS-B algorithm limited-memory “quasi-Newton” method iteratively updates parameter estimates approximating inverse Hessian matrix using gradient information history previous iterations. approach allows algorithm approximate curvature posterior distribution efficiently search optimal solution, makes computationally efficient problems large number variables. default, algorithm uses relative change objective function convergence criterion. change objective function iterations falls certain threshold (`factr`) algorithm considered converged. convergence can checked argument convergence output. See ‘Value’. case convergence issue, may necessary investigate adjust optimization parameters facilitate convergence. can done using initial control arguments. argument initial initial points interative optimization algorithm can changed, argument control list can supply following components: maxit: maximum number iterations. Default 100; factr: controls convergence 'L-BFGS-B' method. Convergence occurs reduction objective within factor machine tolerance. Default factr 1e7, gives tolerance 1e-9. exact tolerance can checked multiplying value .Machine$double.eps; pgtol: helps control convergence 'L-BFGS-B' method. tolerance projected gradient current search direction, .e., iteration stop maximum component projected gradient less equal pgtol, pgtol\\(\\geq 0\\). Default zero, check suppressed; trace: non-negative integer. positive, tracing information progress optimization produced. Higher values may produce tracing information: method 'L-BFGS-B' six levels tracing. understand exactly see source code optim function stats package; REPORT: frequency reports 'L-BFGS-B' method 'control$trace' positive. Default every 10 iterations; lmm: integer giving number BFGS updates retained 'L-BFGS-B' method. Default 5.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Maximum A Posteriori estimation — MAP.estimation","text":"Jonker M.., Pazira H. Coolen .C.C. (2023). Bayesian Federated Inference Statistical Models. Statistics Medicine, Vol. 0(0), 0-0. <https://doi.org/10.48550/arXiv.2302.07677> Byrd R.H., Lu P., Nocedal J. Zhu C. (1995). limited memory algorithm bound constrained optimization. SIAM Journal Scientific Computing, 16, 1190-1208. <https://doi.org/10.1137/0916069>","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum A Posteriori estimation — MAP.estimation","text":"Hassan Pazira Maintainer: Hassan Pazira hassan.pazira@radboudumc.nl","code":""},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/reference/MAP.estimation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum A Posteriori estimation — MAP.estimation","text":"","code":"#------------- # y ~ Gaussian #------------- # model assumption: theta <- c(1, 2, 2, 2, 1.5)  # model parameters: coefficients and sigma2 = 1.5  #---------------- # Data Simulation #---------------- n   <- 30   # sample size p   <- 3    # number of coefficients without intercept X   <- data.frame(matrix(rnorm(n * p), n, p)) # continuous variables # linear predictor: eta <- theta[1] + theta[2] * X$X1 + theta[3] * X$X2 + theta[4] * X$X3 # inverse of the link function ( g^{-1}(\\eta) = \\mu ): mu  <- gaussian()$linkinv(eta) y   <- rnorm(n, mu, sd = sqrt(theta[5]))  #----------------------------------------------- # MAP estimations for theta and curvature matrix #----------------------------------------------- # MAP estimates with 'intercept' Lambda <- inv.prior.cov(X, lambda = c(0.1, 1), family = gaussian) (fit <- MAP.estimation(y, X, family = gaussian, Lambda)) #> $theta_hat #> (Intercept)          X1          X2          X3      sigma2  #>   1.0240099   1.9199194   1.3165800   1.8723071   0.9628839  #>  #> $A_hat #>             (Intercept)         X1         X2         X3     sigma2 #> (Intercept)  31.2564055  5.6577880  1.2500273  0.3060200 -0.2047539 #> X1            5.6577880 55.0628306  2.2659327 -7.2625917 -0.3852721 #> X2            1.2500273  2.2659327 28.8411051  1.6360838 -0.2632052 #> X3            0.3060200 -7.2625917  1.6360838 34.3499640 -0.3738442 #> sigma2       -0.2047539 -0.3852721 -0.2632052 -0.3738442 63.8511656 #>  #> $sd #> (Intercept)          X1          X2          X3      sigma2  #>   0.1807469   0.1383049   0.1869726   0.1734802   0.1251559  #>  #> $Lambda #>             (Intercept)  X1  X2  X3 sigma2 #> (Intercept)         0.1 0.0 0.0 0.0      0 #> X1                  0.0 0.1 0.0 0.0      0 #> X2                  0.0 0.0 0.1 0.0      0 #> X3                  0.0 0.0 0.0 0.1      0 #> sigma2              0.0 0.0 0.0 0.0      1 #>  #> $formula #> [1] y ~ X1 + X2 + X3 #>  #> $names #> [1] \"(Intercept)\" \"X1\"          \"X2\"          \"X3\"          \"sigma2\"      #>  #> $n #> [1] 30 #>  #> $np #> [1] 4 #>  #> $value #> [1] 31.78827 #>  #> $family #> [1] \"gaussian\" #>  #> $intercept #> [1] TRUE #>  #> $convergence #> [1] 0 #>  #> $control #> list() #>  #> attr(,\"class\") #> [1] \"bfi\" class(fit) #> [1] \"bfi\" summary(fit, cur_mat = TRUE) #>  #> Summary of the model: #>  #>    Formula: y ~ X1 + X2 + X3  #>     Family: ‘gaussian’  #>       Link: ‘identity’ #>  #> Coefficients: #>  #>             Estimate Std.Dev CI 2.5% CI 97.5% #> (Intercept)   1.0240  0.1807  0.6698   1.3783 #> X1            1.9199  0.1383  1.6488   2.1910 #> X2            1.3166  0.1870  0.9501   1.6830 #> X3            1.8723  0.1735  1.5323   2.2123 #>  #> Dispersion parameter (sigma2):  0.9629  #>                  log Lik Post:  -31.79  #>                   Convergence:  0  #>  #> Curvature Matrix:  #>  #>             (Intercept)      X1      X2      X3  sigma2 #> (Intercept)     31.2564  5.6578  1.2500  0.3060 -0.2048 #> X1               5.6578 55.0628  2.2659 -7.2626 -0.3853 #> X2               1.2500  2.2659 28.8411  1.6361 -0.2632 #> X3               0.3060 -7.2626  1.6361 34.3500 -0.3738 #> sigma2          -0.2048 -0.3853 -0.2632 -0.3738 63.8512  # MAP estimates without 'intercept' Lambda <- inv.prior.cov(X, lambda = c(0.1, 1), family = gaussian, intercept = FALSE) (fit1 <- MAP.estimation(y, X, family = gaussian, Lambda, intercept = FALSE)) #> $theta_hat #>       X1       X2       X3   sigma2  #> 2.023492 1.346887 1.896484 1.904657  #>  #> $A_hat #>                X1         X2         X3     sigma2 #> X1     27.8860125  1.1455239 -3.6715442 -0.4049573 #> X2      1.1455239 14.6298322  0.8271089 -0.2693011 #> X3     -3.6715442  0.8271089 17.4147911 -0.3790152 #> sigma2 -0.4049573 -0.2693011 -0.3790152 67.6181535 #>  #> $sd #>        X1        X2        X3    sigma2  #> 0.1924879 0.2623820 0.2435170 0.1216282  #>  #> $Lambda #>         X1  X2  X3 sigma2 #> X1     0.1 0.0 0.0      0 #> X2     0.0 0.1 0.0      0 #> X3     0.0 0.0 0.1      0 #> sigma2 0.0 0.0 0.0      1 #>  #> $formula #> [1] y ~ X1 + X2 + X3 #>  #> $names #> [1] \"X1\"     \"X2\"     \"X3\"     \"sigma2\" #>  #> $n #> [1] 30 #>  #> $np #> [1] 3 #>  #> $value #> [1] 54.08866 #>  #> $family #> [1] \"gaussian\" #>  #> $intercept #> [1] FALSE #>  #> $convergence #> [1] 0 #>  #> $control #> list() #>  #> attr(,\"class\") #> [1] \"bfi\" summary(fit1, cur_mat = TRUE) #>  #> Summary of the model: #>  #>    Formula: y ~ X1 + X2 + X3  #>     Family: ‘gaussian’  #>       Link: ‘identity’ #>  #> Coefficients: #>  #>    Estimate Std.Dev CI 2.5% CI 97.5% #> X1   2.0235  0.1925  1.6462   2.4008 #> X2   1.3469  0.2624  0.8326   1.8611 #> X3   1.8965  0.2435  1.4192   2.3738 #>  #> Dispersion parameter (sigma2):  1.905  #>                  log Lik Post:  -54.09  #>                   Convergence:  0  #>  #> Curvature Matrix:  #>  #>             X1      X2      X3  sigma2 #> X1     27.8860  1.1455 -3.6715 -0.4050 #> X2      1.1455 14.6298  0.8271 -0.2693 #> X3     -3.6715  0.8271 17.4148 -0.3790 #> sigma2 -0.4050 -0.2693 -0.3790 67.6182"},{"path":"https://hassanpazira.github.io/BFI/reference/Nurses.html","id":null,"dir":"Reference","previous_headings":"","what":"Nurses' stress in different hospitals — Nurses","title":"Nurses' stress in different hospitals — Nurses","text":"dataset comprises three-level simulated data extracted hypothetical study investigating stress levels within hospital settings. dataset focuses nurses working specific wards within various hospitals. includes several variables, nurse age (measured years), nurse experience (measured years), nurse gender (0 male, 1 female), ward type (0 general care, 1 special care), hospital size (0 small, 1 medium, 2 large). data package edited less columns source data.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/Nurses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nurses' stress in different hospitals — Nurses","text":"","code":"data(Nurses)"},{"path":"https://hassanpazira.github.io/BFI/reference/Nurses.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Nurses' stress in different hospitals — Nurses","text":"https://multilevel-analysis.sites.uu.nl/datasets/","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/Nurses.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nurses' stress in different hospitals — Nurses","text":"Hox, J., Moerbeek, M., van de Schoot, R. (2010). Multilevel Analysis: Techniques Applications, Second Edition (2nd ed.). Routledge. <https://doi.org/10.4324/9780203852279>","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"inv.prior.cov builds diagonal inverse covariance matrix Gaussian prior distribution based design matrix covariates, takes account number regression parameters case categorical covariates.  case linear model, also includes variance measurement errors.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"","code":"inv.prior.cov(X, lambda = 1, family = gaussian, stratified = FALSE,               strat_par = NULL, intercept = TRUE)"},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"X design matrix dimension \\(n \\times p\\), \\(n\\) number samples observed, \\(p\\) number predictors/variables. lambda vector used diagonal (inverse covariance) matrix created inv.prior.cov(). length vector depends number columns X, type covariates (continuous/dichotomous categorical), family, whether intercept included model, whether stratified analysis desired. stratified = FALSE, lambda single positive number (values vector equal), vector two elements (first used regression parameters including ``intercept'' second ``sigma2''), vector length equal number model parameters. However, length lambda different stratified = TRUE, see ‘Details’ information. Default lambda = 1. family description error distribution link function used specify model. can character string naming family function result call family function (see family details). current version, family model can gaussian (identity link function) binomial (logit link function). default gaussian family used. case linear regression model, family = gaussian, extra model parameter variance measurement error. intercept logical flag intercept. changing intercept dimension inverse covariance matrix changes. intercept = TRUE (default), output matrix created inv.prior.cov() one row one column related intercept, intercept = FALSE, resulting matrix row column called intercept. stratified logical flag performing stratified analysis. stratified = TRUE, parameter(s) selected strat_par argument allowed different across centers. Default stratified = FALSE. See ‘Details’ ‘Examples’. strat_par one- two-element integer vector indicating stratification parameter(s). values \\(1\\) /\\(2\\) /used indicate ``intercept'' /``sigma2'' allowed vary, respectively. argument used stratified = TRUE. Default strat_par = NULL, stratified = TRUE, strat_par can NULL. binomial family length vector one refers ``intercept'', value element \\(1\\). gaussian vector can \\(1\\) indicating ``intercept'' , \\(2\\) indicating ``sigma2'' , c(\\(1\\), \\(2\\)) ``intercept'' ``sigma2''. See ‘Examples’.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"inv.prior.cov creates diagonal matrix vector lambda diagonal. stratified = TRUE, length vector lambda depends covariate matrix X, family, whether ``intercept'' included model. example, design matrix X p columns continuous dichotomous covariates, family = gaussian, intercept = TRUE, lambda \\(p+2\\) elements. case, X categorical covariates \\(q>2\\) categories, length lambda increases \\(q-2\\) unit categorical covariate. values non-negative represent variance Gaussian prior. Note , values vector lambda equal, one value enough given entry. lambda scalar, function inv.prior.cov sets value diagonal equal lambda. linear regression model last parameter assumed variance measurement error. lambda two dimensional, first value used prior regression parameters second variance measurement error. stratified = TRUE strat_par = \\(1\\), lambda vector \\(L+p+1\\) elements \\(\\) number regression parameters except intercept (first \\(L\\) elements used \\(L\\) different ``intercept''s locatoins, \\((L+1)^{\\th}\\) \\((L+p)^{\\th}\\) elements used regression parameters excluding intercept last value used ``sigma2''). stratified = TRUE strat_par = \\(2\\), lambda vector \\(1+p+L\\) elements first element used ``intercept''s locatoins, \\((L+1)^{\\th}\\) \\((L+2)^{\\th}\\) elements used regression parameters (excluding intercept) ``sigma2'', respectively). stratified = TRUE strat_par = c(\\(1\\), \\(2\\)), lambda vector \\(2L+1\\) elements. intercept = FALSE, binomial family stratified analysis possible therefore stratified can TRUE. output inv.prior.cov() used main functions MAP.estimation() bfi().","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"inv.prior.cov returns diagonal matrix. dimension matrix depends number columns X, type covariates (continuous/dichotomous categorical), family, intercept.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"Jonker M.., Pazira H. Coolen .C.C. (2023). Bayesian Federated Inference Statistical Models, Statistics Medicine, Vol. 0(0), 0-0. <https://doi.org/10.48550/arXiv.2302.07677>","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"Hassan Pazira Maintainer: Hassan Pazira hassan.pazira@radboudumc.nl","code":""},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/reference/inv.prior.cov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates an inverse covariance matrix for a Gaussian prior — inv.prior.cov","text":"","code":"#---------------- # Data Simulation #---------------- X <- data.frame(x1=rnorm(50),                     # standard normal variable                 x2=sample(0:2, 50, replace=TRUE), # categorical variable                 x3=sample(0:1, 50, replace=TRUE)) # dichotomous variable X$x2 <- as.factor(X$x2) X$x3 <- as.factor(X$x3)  # The (inverse) variance value (lambda=0.05) is assumed to be # the same for Gaussian prior of all parameters  # y ~ Binomial with intercept inv.prior.cov(X, lambda=0.05, family=binomial) # returns a 5-by-5 matrix #>             (Intercept)   x1  x21  x22  x31 #> (Intercept)        0.05 0.00 0.00 0.00 0.00 #> x1                 0.00 0.05 0.00 0.00 0.00 #> x21                0.00 0.00 0.05 0.00 0.00 #> x22                0.00 0.00 0.00 0.05 0.00 #> x31                0.00 0.00 0.00 0.00 0.05  # y ~ Binomial without intercept inv.prior.cov(X, lambda=0.05, family=\"binomial\", intercept = FALSE) # a 4-by-4 matrix #>       x1  x21  x22  x31 #> x1  0.05 0.00 0.00 0.00 #> x21 0.00 0.05 0.00 0.00 #> x22 0.00 0.00 0.05 0.00 #> x31 0.00 0.00 0.00 0.05  # y ~ Gaussian with intercept inv.prior.cov(X, lambda=0.05, family=gaussian) # a 6-by-6 matrix #>             (Intercept)   x1  x21  x22  x31 sigma2 #> (Intercept)        0.05 0.00 0.00 0.00 0.00   0.00 #> x1                 0.00 0.05 0.00 0.00 0.00   0.00 #> x21                0.00 0.00 0.05 0.00 0.00   0.00 #> x22                0.00 0.00 0.00 0.05 0.00   0.00 #> x31                0.00 0.00 0.00 0.00 0.05   0.00 #> sigma2             0.00 0.00 0.00 0.00 0.00   0.05"},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing BFI Fits — summary.bfi","title":"Summarizing BFI Fits — summary.bfi","text":"Summary method object class 'bfi' created MAP.estimation function.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing BFI Fits — summary.bfi","text":"","code":"# S3 method for bfi summary(object, cur_mat = FALSE,         digits = max(3, getOption(\"digits\") - 3), ...)"},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing BFI Fits — summary.bfi","text":"object fitted bfi object. cur_mat logical; TRUE, minus curvature matrix around estimated parameters returned printed. Default FALSE. digits significant digits printout. ... additional arguments affecting summary produced.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarizing BFI Fits — summary.bfi","text":"summary.bfi() gives information MAP estimates parameters model. can used bfi objects built MAP.estimation function. output summary method shows details model, .e. formula, family link function used specify generalized linear model, followed information estimates, standard deviations credible intervals. Information log-likelihood posterior convergence status also provided. default, summary.bfi function return curvature matrix, user can use cur_mat = TRUE print .","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing BFI Fits — summary.bfi","text":"summary.bfi returns object class summary.bfi, list following components: theta_hat component object. last element vector estimate dispersion parameter (sigma2) family = gaussian. See MAP.estimation function. A_hat component object. See MAP.estimation function. sd component object. family = gaussian, last element vector square root estimated dispersion. See MAP.estimation function. Lambda component object. See MAP.estimation function. formula component object. See MAP.estimation function. n component object. See MAP.estimation function. np component object. See MAP.estimation function. family component object. See MAP.estimation function. intercept component object. See MAP.estimation function. convergence component object. See MAP.estimation function. control component object. See MAP.estimation function. Estimate estimated regression coefficients, .e., without estimate sigma2. logLikPost value log-likelihood posterior density corresponding estimates (theta_hat). link link function. default gaussian family identity link function binomial family logit link function used. dispersion estimated variance random error, .e., sigma2. dispersion taken 1 binomial family. CI 95% credible interval MAP estimates parameters.","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summarizing BFI Fits — summary.bfi","text":"Hassan Pazira Maintainer: Hassan Pazira hassan.pazira@radboudumc.nl","code":""},{"path":[]},{"path":"https://hassanpazira.github.io/BFI/reference/summary.bfi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing BFI Fits — summary.bfi","text":"","code":"#------------- # y ~ Gaussian #------------- # model assumption: theta <- c(1, 2, 3, 4, 1.5)  # coefficients and sigma2 = 1.5  #---------------- # Data Simulation #---------------- n      <- 40 X      <- data.frame(x1=rnorm(n),                     # continuous variable                      x2=sample(1:3, n, replace=TRUE)) # categorical variable Xx2_1  <- ifelse(X$x2 == '2', 1, 0) Xx2_2  <- ifelse(X$x2 == '3', 1, 0) X$x2   <- as.factor(X$x2) eta    <- theta[1] + theta[2] * X$x1 + theta[3] * Xx2_1 + theta[4] * Xx2_2 mu     <- gaussian()$linkinv(eta) y      <- rnorm(n, mu, sd = sqrt(theta[5]))  #---------------- # MAP estimations #---------------- Lambda <- inv.prior.cov(X, lambda = c(0.1, 0.5), family = gaussian) fit    <- MAP.estimation(y, X, family = gaussian, Lambda) class(fit) #> [1] \"bfi\"  #------------------------- # Summary of MAP estimates #------------------------- summary(fit) #>  #> Summary of the model: #>  #>    Formula: y ~ x1 + x2  #>     Family: ‘gaussian’  #>       Link: ‘identity’ #>  #> Coefficients: #>  #>             Estimate Std.Dev CI 2.5% CI 97.5% #> (Intercept)   0.8614  0.3024  0.2687   1.4540 #> x1            2.1438  0.1876  1.7761   2.5115 #> x22           3.0041  0.4185  2.1839   3.8243 #> x23           4.4571  0.5034  3.4705   5.4437 #>  #> Dispersion parameter (sigma2):  1.358  #>                  log Lik Post:  -57.01  #>                   Convergence:  0  sumfit <- summary(fit, cur_mat = TRUE) #>  #> Summary of the model: #>  #>    Formula: y ~ x1 + x2  #>     Family: ‘gaussian’  #>       Link: ‘identity’ #>  #> Coefficients: #>  #>             Estimate Std.Dev CI 2.5% CI 97.5% #> (Intercept)   0.8614  0.3024  0.2687   1.4540 #> x1            2.1438  0.1876  1.7761   2.5115 #> x22           3.0041  0.4185  2.1839   3.8243 #> x23           4.4571  0.5034  3.4705   5.4437 #>  #> Dispersion parameter (sigma2):  1.358  #>                  log Lik Post:  -57.01  #>                   Convergence:  0  #>  #> Curvature Matrix:  #>  #>             (Intercept)      x1     x22     x23  sigma2 #> (Intercept)     29.5623 -3.2379 12.5215  5.8925 -0.1723 #> x1              -3.2379 30.9643  2.5870 -2.4480 -0.4288 #> x22             12.5215  2.5870 12.6215  0.0000 -0.6008 #> x23              5.8925 -2.4480  0.0000  5.9925 -0.8914 #> sigma2          -0.1723 -0.4288 -0.6008 -0.8914 82.7153 sumfit$Estimate #> [1] 0.8613571 2.1437962 3.0040962 4.4571093 sumfit$logLikPost #> [1] -57.01121 sumfit$dispersion #>   sigma2  #> 1.357668  sumfit$CI #>                 2.5 %   97.5 % #> (Intercept) 0.2686705 1.454044 #> x1          1.7761183 2.511474 #> x22         2.1838523 3.824340 #> x23         3.4705020 5.443717 class(sumfit) #> [1] \"summary.bfi\""},{"path":"https://hassanpazira.github.io/BFI/reference/trauma.html","id":null,"dir":"Reference","previous_headings":"","what":"Trauma patients from different hospitals — trauma","title":"Trauma patients from different hospitals — trauma","text":"data set consists data 371 trauma patients three hospitals. binary variable mortality used outcome, variables age, sex, Injury Severity Score (ISS, ranging 1 (low) 75 (high)) Glasgow Coma Scale (GCS, expresses level consciousness, ranging 3 (low) 15 (high)) used covariates. data originate multiple hospitals can categorized three groups : peripheral hospital without neuro-surgical unit (Status = 1), peripheral hospital neuro-surgical unit (Status = 2), academic medical center (Status = 3).","code":""},{"path":"https://hassanpazira.github.io/BFI/reference/trauma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trauma patients from different hospitals — trauma","text":"","code":"data(trauma)"},{"path":"https://hassanpazira.github.io/BFI/reference/trauma.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Trauma patients from different hospitals — trauma","text":"Jonker M.., Pazira H. Coolen .C.C. (2023). Bayesian Federated Inference Statistical Models, Statistics Medicine, Vol. 0(0), 0-0. <https://doi.org/10.48550/arXiv.2302.07677> Draaisma J.M.Th, de Haan .F.J., Goris R.J.. (1989). Preventable Trauma Deaths Netherlands - prospective Multicentre Study, journal Trauma, Vol. 29(11), 1552-1557.","code":""}]
